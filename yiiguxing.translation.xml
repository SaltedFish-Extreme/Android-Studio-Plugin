<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="436" />
    <option name="newTranslationDialogX" value="402" />
    <option name="newTranslationDialogY" value="524" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Called when a network disconnects or otherwise no longer satisfies this request or&#10;callback.&#10;&lt;p&gt;If the callback was registered with requestNetwork() or&#10;registerDefaultNetworkCallback(), it will only be invoked against the last network&#10;returned by onAvailable() when that network is lost and no other network satisfies&#10;the criteria of the request.&#10;&lt;p&gt;If the callback was registered with registerNetworkCallback() it will be called for&#10;each network which no longer satisfies the criteria of the callback.&#10;&lt;p&gt;Do NOT call {@link getNetworkCapabilities(Network)} or&#10;{@link getLinkProperties(Network)} or other synchronous ConnectivityManager methods in&#10;this callback as this is prone to race conditions ; calling these methods while in a&#10;callback may return an outdated or even a null object.&#10;@param network The {@link Network} lost." />
      <item value="Callers should instead use the {@link ConnectivityManager.NetworkCallback} API to&#10;              learn about connectivity changes, or switch to use&#10;              {@link ConnectivityManagergetNetworkCapabilities} or&#10;              {@link ConnectivityManagergetLinkProperties} to get information synchronously. Keep&#10;              in mind that while callbacks are guaranteed to be called for every event in order,&#10;              synchronous calls have no such constraints, and as such it is unadvisable to use the&#10;              synchronous methods inside the callbacks as they will often not offer a view of&#10;              networking that is consistent (that is: they may return a past or a future state with&#10;              respect to the event being processed by the callback). Instead, callers are advised&#10;              to only use the arguments of the callbacks, possibly memorizing the specific bits of&#10;              information they need to keep from one callback to another." />
      <item value="Suppress Lint" />
      <item value="Deprecated Is Still Used" />
      <item value="needed to maintain forward compatibility" />
      <item value="Suppress Warnings" />
      <item value="CALL STACK INDEX" />
      <item value="proguard" />
      <item value="Synthetic stacktrace didn't have enough elements: are you using proguard?" />
      <item value="minify" />
      <item value="minify Enabled" />
      <item value="msg" />
      <item value="wrap Message" />
      <item value="is Link Mode" />
      <item value="Extract the class name without any anonymous class suffixes&#10;      (e.g., `Foo1` becomes `Foo`)." />
      <item value="DO NOT switch this to Thread.getCurrentThread().getStackTrace()." />
      <item value="Synthetic stacktrace didn't have enough elements: are you using proguard" />
      <item value="map Tag" />
      <item value="map Msg" />
      <item value="Extract the class name without any anonymous class suffixes (e.g., {@code Foo1}&#10;      becomes {@code Foo})." />
      <item value="Network State" />
      <item value="Connect" />
      <item value="Network Connect Changed Receiver" />
      <item value="Conflicting declarations: public var wifi: Boolean, public var wifi: Boolean" />
      <item value="is Network Available" />
      <item value="for check internet over Bluetooth" />
      <item value="for other device how are able to connect with Ethernet" />
      <item value="desc" />
      <item value="decs" />
      <item value="Unable to start activity ComponentInfo{com.example.wanandroidcom.example.wanandroid.activity.MainActivity}: java.lang.NullPointerException: Attempt to invoke virtual method 'android.content.pm.ApplicationInfo android.app.Application.getApplicationInfo()' on a null object reference&#10;        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3375)" />
      <item value="Bluetooth" />
      <item value="TRANSPORT BLUETOOTH" />
      <item value="TRANSPORT ETHERNET" />
      <item value="TRANSPORT CELLULAR" />
      <item value="TRANSPORT WIFI" />
      <item value="Check Network State Ext" />
      <item value="Check Network State" />
      <item value="工具" />
      <item value="util" />
      <item value="utils" />
      <item value="get Active Network Info" />
      <item value="Salted-Fish" />
      <item value="Unable to start activity ComponentInfo{com.example.wanandroidcom.example.wanandroid.activity.MainActivity}: kotlin.UninitializedPropertyAccessException: lateinit property mNetworkChangeListener has not been initialized" />
      <item value="A problem occurred evaluating root project 'WanAndroid'.&#10;&gt; Build was configured to prefer settings repositories over project repositories but repository 'maven' was added by build file 'build.gradle'" />
      <item value="A problem occurred evaluating root project 'WanAndroid'.&#10;&gt; Build was configured to prefer settings repositories over project repositories but repository 'Google' was added by build file 'build.gradle'" />
      <item value=" NOTE: Do not place your application dependencies here; they belong&#10;         in the individual module build.gradle files" />
      <item value="persistent State" />
      <item value="Net Work State" />
      <item value="'lateinit' modifier is not allowed on properties of primitive types" />
      <item value="network Status" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="79" />
        <entry key="ENGLISH" value="80" />
        <entry key="FRENCH" value="2" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="VIETNAMESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1638781915489" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
    <option name="showActionsInContextMenuOnlyWithSelection" value="false" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>